# 옵저버 패턴이 무엇이란 무엇인지 설명하고 장단점을 말해주세요

- **자료 조사**
    
    ### 옵저버 패턴 (Observer Pattern)
    
    ![[그림 1] 스타크래프트의 옵저버 유닛](https://github.com/BangDori/CS_interview_Study/blob/main/common%26design_pattern/img/starcraft_observer.png)
    
    스타크래프트의 프로토스 유닛 옵저버는 항시 클로킹한 상태로 시야를 밝히고 클로킹한 유닛을 감지할 수 있다. 여기서 Observer(옵저버)는 ‘관측자’ 혹은 ‘감시자’ 라는 뜻이다. 말 그대로 무언가를 감시하는 역할을 한다는 뜻이다.
    
    프로토스의 옵저버가 클로킹 상태의 테란 유닛 고스트나 레이스를 감시하듯, 프로그래밍에서 **Observer 패턴**이라고 한다면 어떤 ‘**이벤트**’가 일어나는 것을 감시하는 패턴을 의미한다.
    
    <aside>
    💡 **안드로이드를 예로 들어 설명하자면 아래와 같은 것들이 이벤트가 발생한 순간이라고 할 수 있다.**
    
    1. 사용자가 키보드를 눌렀을 때
    2. 사용자가 어떤 버튼을 터치했을 때
    3. 호출한 API의 응답 데이터가 수신됐을 때
    
    </aside>
    
    정리하자면, 아무도 함수로 직접 요청한 적 없지만 **시스템에 의해 발생하는 동작들을 이벤트**라고 한다.
    
    ![[그림 2] 옵저버 패턴](https://github.com/BangDori/CS_interview_Study/blob/main/common%26design_pattern/img/observer_pattern.jpg)
    
    이러한 이벤트들을 위 Subject(주체)가 감시하여, **이벤트가 발생할 때마다 미리 정의해둔 어떠한 동작을 즉각 수행하게 해주는 프로그래밍 패턴을 옵저버 패턴**이라고 한다.
    
    `ex) A 라는 버튼이 클릭될 때마다 화면에 'Hello World'를 출력하는 동작`
    
    옵저버 패턴을 활용하면 **다른 객체의 상태 변화를 별도의 함수 호출 없이 즉각적으로 알 수 있기 때문에**, 이벤트에 대한 처리를 자주 해야 하는 프로그램이라면 매우 **효율적인 프로그램을 작성**할 수 있다.
    
    그럼 이제 옵저버 패턴의 원리를 살펴보자.
    
    ### 옵저버 패턴의 구현 원리
    
    옵저버는 어떤 식으로 구현해볼 수 있을까? 우선 예시를 하나 들어보자.
    
    이벤트를 발생하는 클래스 B가 있고, 이 B 클래스가 발생하는 이벤트를 수신받고 싶어하는 클래스 A가 있는 상황을 가정해보자. 그럼 머릿속으로 이벤트 처리 동작을 이렇게 구현해볼 수 있을 것이다.
    
    > 아래 그림처럼, 먼저 클래스 A에서 B의 이벤트를 수신받기 위해 클래스 B를 인스턴스화 한 뒤, B가 자신에게 이벤트가 발생할 때마다 클래스 A가 갖고있는 메소드를 호출하도록 시키는 것이다.
    > 
    
    ![[그림 3] 옵저버 패턴을 구현한 그림 1](https://github.com/BangDori/CS_interview_Study/blob/main/common%26design_pattern/img/observer_pattern-1.png)
    
    위 그림은 크게 나쁘지 않게 잘 설계된 구조라고 생각이 들 수 있다. 하지만. 치명적인 문제가 있는 구조이다. 아래 그림을 확인해보자.
    
    ![[그림 4] 옵저버 패턴을 구현한 그림 2](https://github.com/BangDori/CS_interview_Study/blob/main/common%26design_pattern/img/observer_pattern-2.png)
    
    클래스 B는 이벤트를 정상적으로 발생하고 있지만, A가 B를 일방적으로 인스턴스화 한 상황이기 때문에, B가 자신을 인스턴스화 한 대상에게 접근할 방법이 전혀 없다는 점이다. 사실 당연하게 B는 A의 메소드를 호출하지 못한다.
    
    그렇다면, 어떤 방식으로 옵저버 패턴을 구현해볼 수 있을까? 해답은 ‘**인터페이스**’를 이용하는 것이다.
    
    ![[그림 5] 옵저버 패턴을 구현한 그림 3](https://github.com/BangDori/CS_interview_Study/blob/main/common%26design_pattern/img/observer_pattern-3.png)
    
    위 예시에는 A가 중간에 종을 만들어, B가 이벤트가 발생할 때마다 A가 만들어둔 종을 울리도록 한다. A는 종이 울릴 때마다 이를 알아차리고 이벤트가 감지됐을 때 수행할 동작을 자연스럽게 하는 플로우가 나온다.
    
    즉, 둘 사이에 인터페이스를 하나 끼워넣는 방식이다. A는 인터페이스를 상속하여 이벤트가 발생할 때마다 실행되게 할 메소드를 구현해둔다. 그리고 B를 생성할 때 인터페이스 구현체를 전달하여, 이벤트가 발생할 때마다 생성자로 전달받은 A가 구현한 인터페이스 메소드를 호출하면 된다.
    
    > 이 때, 위 인터페이스(종)를 Observer (옵저버)라고 부른다. 코틀린에서는 Listener(리스너)라는 용어를 사용한다.
    
    그리고 B가 구현된 인터페이스 메소드를 호출함으로써 이벤트를 전달하는 행위를 Callback(콜백) 이라고 한다.
    > 
    
    ### 옵저버 패턴의 장단점
    
    **장점**
    
    1. 느슨한 결합(Losse coupling): 옵저버 패턴은 주체 객체와 옵저버 패턴들 사이에 느슨한 결합을 제공합니다. 주체 객체는 옵저버에 대한 어떤 정보도 알지 못하며, 옵저버 역시 주체 객체의 구체적인 세부 정보를 알 필요가 없습니다. 이는 객체들 간의 상호 의존성을 최소화하고, 유연성과 재사용성을 높여줍니다.
    2. 확장성(Scalability): 옵저버 패턴은 새로운 주체 객체나 옵저버 객체를 추가하는 것이 비교적 간단합니다. 주체 객체에 옵저버를 등록하고 알림을 보내는 구조를 유지하면, 시스템을 유연하게 확장할 수 있습니다. 이는 코드의 변경을 최소화하면서 새로운 기능을 추가할 수 있는 장점을 제공합니다.
    3. 이벤트 기반 구조: 옵저버 패턴은 이벤트 기반 시스템에서 주로 사용됩니다. 주체 객체의 상태 변화에 따라 발생하는 이벤트를 처리하는 데에 옵저버 패턴을 적용하면, 이벤트 처리와 관련된 로직을 분리하여 코드를 구성할 수 있습니다. 이는 코드의 가독성과 유지보수성을 향상시킬 수 있습니다.
    
    **단점**
    
    1. 성능 저하: 옵저버 패턴은 주체 객체의 상태 변환 시 모든 옵저버 객체에게 알림을 보내야 합니다. 따라서 옵저버의 수가 많을수록 알림을 처리하는 데에 시간이 더 걸리고, 성능이 저하될 수 있습니다. 성능이 중요한 시스템에서는 이를 고려해야 합니다
    2. 순서 의존성: 옵저버들 사이에는 등록 순서에 따라 실행 순서가 결정될 수 있습니다. 따라서 옵저버들 간에 서로에게 의존성이 있을 경우, 원하는 순서로 실행되지 않을 수 있습니다. 이는 주의해야 할 점입니다.
    
    ### 옵저버 패턴의 활용
    
    옵저버 패턴은 어떤 상황에 좋을까요?
    
    옵저버 패턴은 다음과 같은 상황들에서 유용할 수 있습니다.
    
    1. **이벤트 기반 시스템**
        
        이벤트 기반 시스템에서는 주로 옵저버 패턴이 활용됩니다. 예를 들어, 그래픽 사용자 인터페이스(GUI)에서는 버튼 클릭, 마우스 이동, 키 입력 등의 이벤트에 대한 처리를 옵저버 패턴을 통해 구현할 수 있습니다. 주체 객체(이벤트 발생자)는 이벤트가 발생할 때마다 등록된 옵저버들에게 알림을 보내어 적절한 동작을 수행하도록 합니다.
        
    2. **상태 변화 감지**
        
        주체 객체의 상태 변화를 감지하고 이에 대한 처리가 필요한 경우 옵저버 패턴을 사용할 수 있습니다. 예를 들어, 주식 시장에서는 가격 변동에 따라 다양한 트레이딩 알고리즘이 실행되어야 할 수 있습니다. 주식 시장은 주체 객체이고, 트레이딩 알고리즘은 옵저버 객체로 등록되어 가격 변동에 따라 적절한 행동에 취하도록 할 수 있습니다.
        
    3. **분산 시스템**
        
        분산 시스템에서는 여러 컴포넌트나 서비스가 동작하며, 각 컴포넌트는 다른 컴포넌트의 상태 변화를 감지해야 할 수 있습니다. 이런 경우에 옵저버 패턴을 활용하여 분산 시스템 내의 컴포넌트 간 상호작용을 단순화하고, 효율적인 통신과 상태 관리를 할 수 있습니다.
        
    4. **UI 업데이트**
        
        사용자 인터페이스(UI)에서 주로 발생하는 상황 중 하나는 데이터의 변화에 따라 UI를 업데이트해야 하는 경우입니다. 이때 옵저버 패턴을 사용하면 데이터 변경 시 자동으로 UI를 갱신하고 반영할 수 있습니다. 예를 들어, 주문 상태가 변경되면 관련된 UI 요소들이 자동으로 업데이트 되는 기능을 구현할 수 있습니다.
        
    
    옵저버 패턴은 상호작용이 필요한 객체 간의 결합도를 낮추고, 확장성과 유연성을 제공하는데 적합한 디자인 패턴입니다.
    
- **답안**
    
    옵저버 패턴은 이벤트가 발생할 때마다 미리 정의해둔 어떠한 동작을 즉각 수행하게 해주는 디자인 패턴을 의미하며, 어떤 객체의 상태가 변할 때 관련된 다른 객체들에게 자동으로 알림을 보내도록 하는 것을 목적으로 합니다.
    
    옵저버 패턴은 주로 이벤트 기반 시스템에서 사용되며, 이벤트 발생 시 이벤트를 수신할 객체들에게 알림을 전달하는 구조를 제공합니다. 
    
    옵저버 패턴은 주체 객체와 옵저버 패턴들 사이에 느슨한 결합을 제공하기 때문에, 의존성을 최소화하고 유연성과 재사용성을 높여준다는 장점이 존재합니다. 하지만, 옵저버 패턴은 주체 객체의 상태 변환 시 모든 옵저버 객체에게 알림을 보내야 하기 때문에, 옵저버의 수가 많을수록 알림을 처리하는 데에 시간이 더 걸리고, 성능이 저하될 수 있다는 단점이 있습니다.
    
- **참고 자료**
    
    [https://velog.io/@haero_kim/옵저버-패턴-개념-떠먹여드립니다](https://velog.io/@haero_kim/%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4-%EA%B0%9C%EB%85%90-%EB%96%A0%EB%A8%B9%EC%97%AC%EB%93%9C%EB%A6%BD%EB%8B%88%EB%8B%A4)
    
    [https://chat.openai.com/](https://chat.openai.com/)
