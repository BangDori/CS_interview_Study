# 1차시: 1주차

---

# 우선 순위 큐를 어떻게 구현할 수 있을까요? 가장 효율적인 방법은 무엇일까요?

- 자료조사
    
    ### 우선 순위 큐
    
    - 우선순위를 가진 데이터를 저장하는 큐
    - 우선순위가 높은 순서대로 삭제
    
    예) 운영체제의 작업 스케줄링
    
    ### 우선 순위 큐를 구현하는 방법
    
    ![우선순위큐.png](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/%25EC%259A%25B0%25EC%2584%25A0%25EC%2588%259C%25EC%259C%2584%25ED%2581%2590.png)
    
    - 배열(Array) / 연결리스트(List)
        - 구현이 비교적 간단하다.
        - 삽입, 삭제 연산의 시간복잡도가 높다.
    - 힙(Heap)
        - 구현이 비교적 복잡하다.
        - 삽입, 삭제 연산의 시간복잡도가 O(log2 n)으로 효율적이다.
    
    ### Heap
    
    - 최대 힙(Max Heap) :  최대 트리이면서 완전 이진 트리
    - 최소 힙(Min Heap) :  최소 트리이면서 완전 이진 트리
        
        ![힙.jpg](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/%25ED%259E%2599.jpg)
        
    
    - 최대 트리 : 부모 노드 ≥ 자식 노드
    - 최소 트리 : 부모 노드 ≤ 자식 노드
    - 완전 이진 트리
        - 마지막 레벨을 제외하고 모든 레벨이 채워진 형태
        - 마지막 레벨은 왼쪽부터 채워져야 한다.
    
    ### Max Heap - 삭제 연산 / 삽입 연산 구현
    
    Q. Heap은 일반적으로 배열을 사용하여 구현한다. 그 이유는?
    
    A. 완전 이진 트리이므로 배열로 구현이 가능하다.
    
    만일 연결 리스트로 구현할 경우, 왼쪽/오른쪽 자식 노드에 대한 포인터 정보를 저장해야 하므로 메모리를 더 많이 사용하게 된다.
    
    - 삽입 - O(log2 n)
        - 마지막 노드에 삽입
        - 마지막 노드에서 부모 노드와 비교해가며 트리 재구성
    
    ![최대 힙 - 삽입.png](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/%25EC%25B5%259C%25EB%258C%2580_%25ED%259E%2599_-_%25EC%2582%25BD%25EC%259E%2585.png)
    
    - 삭제 - O(log2 n)
        - root에서만 삭제되며, 마지막 노드를 root로 변경
        - root에서 자식 노드와 비교해가며 트리 재구성
        
        ![최대 힙 - 삭제.png](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/%25EC%25B5%259C%25EB%258C%2580_%25ED%259E%2599_-_%25EC%2582%25AD%25EC%25A0%259C.png)
        
    
    ### Min Heap - 삭제 연산 / 삽입 연산 구현
    
    Max Heap에서 부등호 방향만 반대
    
- 답안
    
    우선 순위 큐는 배열, 연결 리스트, 힙을 통해 구현할 수 있습니다. 삽입, 삭제 연산을 할 때 배열과 연결 리스트의 경우 시간 복잡도가 O(n), 힙의 경우 시간 복잡도가 O(log2 n)입니다. 따라서 힙을 사용하여 우선 순위 큐를 구현하는 것이 가장 효율적입니다.
    
- 코드 예시
    
    ```java
    public class MaxHeap {
        private int[] heap;
        private int size;
        private int capacity;
    
        public MaxHeap(int capacity) {
            this.capacity = capacity;
            this.heap = new int[capacity];
            this.size = 0;
        }
    
        private int parent(int i) {
            return (i - 1) / 2;
        }
    
        private int leftChild(int i) {
            return 2 * i + 1;
        }
    
        private int rightChild(int i) {
            return 2 * i + 2;
        }
    
        private void swap(int i, int j) {
            int temp = heap[i];
            heap[i] = heap[j];
            heap[j] = temp;
        }
    
        public void insert(int value) {
            if (size >= capacity) {
                throw new IndexOutOfBoundsException("Heap is full");
            }
            heap[size] = value; // 마지막 노드에 삽입
            int current = size;
            size++;
            while (heap[current] > heap[parent(current)]) {
                swap(current, parent(current));
                current = parent(current);
            }
        }
    
        public int extractMax() {
            if (size <= 0) {
                throw new IndexOutOfBoundsException("Heap is empty");
            }
            int max = heap[0]; // root에서 삭제
            heap[0] = heap[size - 1]; // 마지막 노드를 root로 변경
            size--;
            heapify(0);
            return max;
        }
    
        private void heapify(int i) {
            int left = leftChild(i);
            int right = rightChild(i);
            int largest = i;
            if (left < size && heap[left] > heap[largest]) {
                largest = left;
            }
            if (right < size && heap[right] > heap[largest]) {
                largest = right;
            }
            if (largest != i) { // 트리 재구성을 해야한다면 swap
                swap(i, largest);
                heapify(largest);
            }
        }
    }
    ```
    
- 참고자료
    
    [이진 트리 구현 배열 vs 리스트](https://velog.io/@keum0821/이진-트리-구현-배열-vs-리스트)
    
    [Heap](https://medium.com/@jyw198908/heap-45bbad579e0c)
    

# Dijkstra 알고리즘과 Bellman-Ford 알고리즘의 차이점을 설명하시오.

- 자료조사
    
    ### Dijkstra 알고리즘
    
    ![1.png](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/1.png)
    
    출발 노드를 1로 설정해보자.
    
    ![2.png](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/2.png)
    
    1에서 갈 수 있는 가장 짧은 경로는 4로 가는 경로이다.
    
    1에서 4로 가는 최단 거리는 7로 결정되었다.
    
    ![3.png](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/3.png)
    
    3으로 갈 수 있는 경로는 다음 두 가지이다.
    
    **1→ 3** = 9,
    
    **1→ 4 → 3** = 7+10
    
    ![4.png](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/4.png)
    
    더 짧은 경로를 선택하자.
    
    1에서 3으로 가는 최단 거리는 9로 결정되었다. 
    
    ![5.png](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/5.png)
    
    2로 갈 수 있는 경로는 다음 2가지이다.
    
    **1 → 2** = 14
    
    **1 → 3 → 2** = 9 + 2
    
    ![6.png](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/6.png)
    
    더 짧은 경로를 선택하자.
    
    1에서 2로 가는 최단 거리는 11로 결정되었다. 
    
    ![7.png](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/7.png)
    
    5로 갈 수 있는 경로는 다음 1가지이다.
    
    **1 → 3 → 2 → 5** = 11 + 9
    
    ![8.png](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/8.png)
    
    1에서 5로 가는 최단 거리는 20으로 결정되었다. 
    
    ![9.png](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/9.png)
    
    6으로 갈 수 있는 경로는 다음 3가지이다.
    
    **1 → 3 → 2 → 5 → 6**= 20 + 6
    
    **1 → 3 → 6**= 9 + 11
    
    **1 → 4 → 6**= 7+ 15
    
    ![10.png](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/10.png)
    
    1에서 6으로 가는 최단 거리는 20으로 결정되었다. 
    
    ### Dijkstra 알고리즘의 한계
    
    ![0.png](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/0.png)
    
    Q. 만일 3과 4를 사이 가중치가 -10이라면 어떻게 될까?
    
    ![1.png](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/1%201.png)
    
    <Dijkstra 알고리즘에서 최단 거리>
    
    ![2.png](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/2%201.png)
    
    <직관적인 관점에서 최단 거리>
    
    A. 음의 가중치가 있는 경우, Dijkstra 알고리즘으로 최단 거리를 구할 수 없다.
    
    이 경우 Bellman-Ford 알고리즘으로 최단 거리를 구할 수 있다.
    
    Dijkstra은 Greedy 알고리즘(탐욕적인 알고리즘)이다.
    
    미래를 생각하지 않고 각 단계에서 최선의 선택을 하는 것이다.
    
    ### Bellman-Ford 알고리즘
    
    1. 시작 정점을 결정한다.
    2. 시작 정점부터 다른 정점까지 거리 값 모두 무한대로 초기화한다. (시작 정점은 0으로 초기화)
    3. 현재 정점의 모든 인접 정점들을 탐색하며, 기존에 기록된 인접 정점까지의 거리보다 현재 정점을 거쳐 인접 정점에 도달하는 거리가 더 짧다면 인접 정점까지의 거리를 갱신한다.
    4. 3번 과정을 *V*−1번 반복한다.
    5. 위 과정을 모두 마친 후에도 거리가 갱신되는 경우가 있다면 그래프에 음수 사이클이 존재한다는 것을 알 수 있다.
    
    ![1.jpg](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/1.jpg)
    
    출발 노드를 1로 설정해보자.
    
    | 0 | ∞ | ∞ | ∞ | ∞ |
    | --- | --- | --- | --- | --- |
    
    노드의 개수 길이로 배열을 초기화한다.
    
    | 0 | -4 | 5 | 2 | 3 |
    | --- | --- | --- | --- | --- |
    
    출발 노드부터 갈 수 있는 경로를 조사한다.
    
    그 다음으로
    
    2번 노드를 거쳐서 갈 수 있는 최단 거리
    
    3번 노드를 거쳐서 갈 수 있는 최단 거리
    
    4번 노드를 거쳐서 갈 수 있는 최단 거리
    
    5번 노드를 거쳐서 갈 수 있는 최단 거리를 구해보자.
    
    ![2.png](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/2%202.png)
    
    | 0 | -4 | 5 | -5 | 3 |
    | --- | --- | --- | --- | --- |
    
    **1→ 4** = 2
    
    **1→ 2 → 4** = -4 + -1
    
    2번 노드를 거쳐서 갈 수 있는 최단 거리
    
    ![3.png](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/3%201.png)
    
    | 0 | -4 | 5 | -5 | 3 |
    | --- | --- | --- | --- | --- |
    
    **1→ 4** = -5
    
    **1→ 3 → 4** = 5 + -7
    
    3번 노드를 거쳐서 갈 수 있는 최단 거리
    
    ![4.png](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/4%201.png)
    
    | 0 | -4 | 5 | -5 | 1 |
    | --- | --- | --- | --- | --- |
    
    **1→ 5** = 3
    
    **1→ 4 → 5** = -5 + 6
    
    4번 노드를 거쳐서 갈 수 있는 최단 거리
    
    ![5.png](1%E1%84%8E%E1%85%A1%E1%84%89%E1%85%B5%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20532221c3be0e4bc9bde292022e7a66f0/5%201.png)
    
    | 0 | -4 | 5 | -5 | 1 |
    | --- | --- | --- | --- | --- |
    
    **1→ 4** = -5
    
    **1→ 5 → 4** = 3 + -4
    
    5번 노드를 거쳐서 갈 수 있는 최단 거리
    
    ### Bellman-Ford 알고리즘 - 음의 사이클 찾는 방법
    
    한 노드에서 다른 한 노드까지 도달하는 데, 최대 V-1만큼의 간선이 사용된다.
    
    즉, V 이상의 간선이 중간 경로로 사용된다면 사이클이 존재하는 것이다.
    
    Bellman-Ford 알고리즘에서 각 노드를 중간 경로로 하여 최단 경로를 찾는 과정을 V번 이상 반복하였을 때 경로가 업데이트 된다면, 사이클이 존재하는 것이다.
    
- 답안
    
    Dijkstra 알고리즘과 Bellman-Ford 알고리즘은 한 정점에서 다른 모든 정점까지의 최단 거리를 구하는 알고리즘입니다. 음의 가중치가 존재할 경우 Dijkstra 알고리즘은 최단 거리를 구할 수 없으나, Bellman-Ford 알고리즘은 최단 거리를 구할 수 있습니다. 다만, Bellman-Ford 알고리즘이 Dijkstra 알고리즘 보다 시간복잡도가 크기 때문에 양의 가중치만 존재하는 경우 Dijkstra 알고리즘을 사용하는 것이 효율적입니다.
    
- 참고자료
    
    [데이크스트라 알고리즘](https://ko.wikipedia.org/wiki/데이크스트라_알고리즘)
    
    [[Algorithm] 벨만포드(BellmanFord) 알고리즘 JAVA](https://developer-davii.tistory.com/m/89)
    
    [최단경로 - (2) 벨만-포드(Bellman-Ford) 알고리즘](https://velog.io/@adorno10/최단경로-2-벨만-포드Bellman-Ford-알고리즘)