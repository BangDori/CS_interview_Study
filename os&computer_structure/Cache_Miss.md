# 캐시 미스(Cache Miss)가 무엇인지 설명해주세요.

- **자료 조사**
    
    > **캐시 미스**는 컴퓨터에서 발생하는 현상으로, CPU가 데이터나 명령어를 찾을 때 캐시 메모리에 해당 데이터나 명령어가 없어서 메인 메모리에서 해당 데이터나 명령어를 가져오는 것을 말합니다.
    > 
    
    컴퓨터에서는 CPU가 명령어를 실행할 때, 해당 명령어에 필요한 데이터를 메모리에서 가져와야 합니다. 이때, CPU는 먼저 캐시 메모리를 확인하고, 캐시 메모리에 해당 데이터나 명령어가 있다면 캐시 히트가 발생하고, 빠르게 데이터나 명령어를 가져올 수 있습니다. 하지만 캐시 메모리에 해당 데이터나 명령어가 없는 경우, CPU는 캐시 미스가 발생하게 되고, 이때는 메인 메모리에서 해당 데이터나 명령어를 가져와야 합니다.
    
    캐시 미스가 발생하면 성능이 저하될 수 있기 때문에, 적절한 캐시 크기와 캐시 알고리즘을 선택하여 캐시 히트율을 높이는 것이 중요합니다. 또한, 캐시 미스가 발생하면 이를 최소화하기 위해 예측 실행 등의 기술을 사용하기도 합니다.
    
    - **Cache Hit**
        
        ![Cache hit](https://github.com/BangDori/CS_interview_Study/blob/main/os%26computer_structure/img/cache_hit.png)
        
        CPU가 값을 가져오려고 할 때 Cache Memory에 해당하는 값이 있다면 Memory까지 가지 않고 Cache까지만 가서 값을 가져올 수 있습니다. 이 경우를 Cache Hit이라고 합니다.
        
    - **Cache Miss**
        
        ![Cache miss](https://github.com/BangDori/CS_interview_Study/blob/main/os%26computer_structure/img/cache_miss.png)
        
        반대의 경우 CPU가 값을 가져오려고 할 때 Cache에 해당하는 값이 없다면 Main Memeory까지 가서 값을 가져와야 합니다. 이 경우를 Cache Miss라고 합니다.
        
    - **캐시 미스의 주요 원인 (3C)**
        - **Compulsory miss**
            - 캐시를 초기화하거나, 처음에 접근하는 블록에 대해 발생하는 캐시 미스입니다. 이는 캐시에 해당 블록이 존재하지 않기 때문에 발생하는 미스로 피할 수 없습니다.
            
            - 예를 들어, 프로그램이 처음으로 실행될 때, 데이터나 명령어 블록이 캐시에 없는 상태에서 접근하게 되면 Compulsory miss가 발생하게 됩니다.
            
            - 따라서, 캐시의 크기나 구성 등을 고려하며, Compulsory miss를 최소화하는 것이 중요합니다. 이를 위해서는 프로그램 실행 전에 적절한 초기화 작업을 수행하거나, 미리 캐시에 필요한 명령어 블록을 적재하는 프리로딩(preloading) 기법 등을 사용할 수 있습니다.
        - **Capacity miss**
            - 캐시의 용량이 부족하여 발생하는 미스입니다. 이는 캐시에 존재할 수 있는 블록의 수가 한정되어 있기 때문에 발생하게 됩니다.
            
            - 캐시는 한정된 용량을 가지고 있기 때문에, 캐시에 저장할 수 있는 블록의 수가 모두 채워지면, 새로운 블록이 캐시에 적재되려고 할 때 기존에 존재하던 블록 중 하나를 대체해야 합니다. 이때 대체되는 블록이 나중에 다시 필요해지는 경우, 해당 블록이 메인 메모리에서 다시 가져와지게 되므로 Capacity miss가 발생하게 됩니다.
            
            - Capacity miss를 줄이기 위해서는 캐시의 크기를 늘리거나, 캐시와 메인 메모리 사이의 전송 대역폭을 늘리는 방법이 있습니다. 또한 캐시 크기를 늘릴 수 없는 경우에는 캐시에 자주 접근하는 데이터나 명령어를 더 많이 적재하는 것이 유용할 수 있습니다. 이를 위해 데이터나 명령어의 로컬리티(locality)를 파악하고, 적절한 프리페칭(prefetching) 기법을 사용하는 것이 중요합니다.
        - **Conflict miss**
            - 캐시의 구조에 기인하여 발생하는 캐시 미스입니다. 캐시의 구조는 직접 사상 캐시, 집합 연관, 완전 연관 등 다양한 방식으로 구성될 수 있습니다.
        - **(if 4C model) Coherence miss**
            
            멀티 코어가 대두 되면서 각 코어마다 캐시를 장착하게 되었다. 이러한 시스템에서는 코어 캐시 간 일관성이 중요하다. 이 때문에 한 코어에서 캐시 라인 업데이트 시, 일관성을 위해 다른 코어의 캐시라인이 무효화 된다. 무효화된 데이터를 재 접근시 발생하는 캐시 미스이다.
            
            - **False sharing (거짓 공유)**
                
                서로 다른 두 변수가 locality에 의해 같은 캐시 라인을 쓰는 경우가 발생한다. 예를 들어 8바이트 캐시 라인을 사용한다고 가정하고 다음과 같은 상황을 생각해보자.
                
                상황
                
                - 각 코어는 8바이트 캐시라인을 가지고 있다.
                - int A, B 변수는 서로 근접하고 있다.
                - 코어 0번 캐시에는 한 캐시 라인에 A, B가 같이 올라가 있다.
                - 코어 1번 캐시에는 한 캐시 라인에 A, B가 같이 올라가 있다.
                - 코어 0번 프로그램은 A에 쓰기를 매번 시도한다.
                - 코어 1번 프로그램은 B에 읽기를 매번 시도한다.
                
                위 상황의 경우, 코어 0번은 A만 접근하고 코어 1번은 B만 접근하므로 두 코어는 변수를 공유하지 않는다. 하지만 A, B 변수가 캐시 라인을 공유한다.
                
                코어 0번 캐시의 A 데이터를 write하면 A 데이터의 캐시 일관성을 위해 A 데이터를 가진 코어 1번 캐시 라인의 캐시라인이 invalidate 된다. 코어 1번 프로그램은 B만 읽지만 코어 0번 때문에 캐시라인이 invalidate 되어 B 데이터 접근할 때, cache miss가 발생하는 일을 겪는다.
                
                이와같이 실제로 변수를 공유하지 않지만 캐시 라인을 공유하는 상황때문에 cache miss가 발생하는것을 false sharing이라 한다.
                
    
    ---
    
    - **캐시 사상 방식**
        - **직접 사상(direct mapped) 캐시**
            
            메모리의 주소가 여러 개의 집합(set)중 하나에 매핑됩니다. 서로 다른 메모리 주소가 같은 캐시 인덱스에 매핑되면 Conflict miss가 발생합니다.
            
            ![Direct mapped cache](https://github.com/BangDori/CS_interview_Study/blob/main/os%26computer_structure/img/direct_mapped_cache.png)
           
            위 그림은 direct mapped cache를 나타내고 있습니다. 이 캐시는 메인 메모리의 64개의 블록을 저장할 수 있으며, 각 블록의 크기는 1 word 입니다. 캐시의 인덱스는 메모리 주소의 하위 비트를 이용하여 계산됩니다.
            
            ex) main memory 00**00 0001** → cache memory 의 첫 번째 인덱스인 00**000001** 저장
            
            캐시 메모리 1번 인덱스에 메인 메모리의 00**000001** 주소의 블록이 저장되어 있다고 가정해보겠습니다. 이때, 사용자의 요청에 의해 11**000001** 주소의 블록이 필요하다면 우선 캐시 메모리에 해당 블록이 존재하는지 확인하고 없다면, 메인 메모리에 이동해 블록을 찾게 됩니다. 메인 메모리 블록에서 11**000001** 을 캐시 메모리에 올리게 되는데 1번 인덱스에는 이미 00**000001** 있기 때문에 Conflict miss가 발생하게 됩니다.
            
        - **집합 연관(set associative) 캐시**
            
            집합 연관 캐시는 직접 사상 캐시와 완전 연관 캐시의 중간 형태로, 캐시 슬롯의 일부분을 묶어서 set으로 만들고, 각 set 내에서는 direct mapped 방식을 사용하는 캐시입니다.
            
            간단하게 말하자면, set이 1개의 block으로 구성되어 있다면 direct-mapped cache이고, 각 set에 2개, 3개, n개의 캐시 라인으로 구성되어 있다면 2-way, 3-way, n-way set-associative cache라고 합니다.
            
            ![Set associative cache](https://github.com/BangDori/CS_interview_Study/blob/main/os%26computer_structure/img/set_associative_cache.png)
            
            위 그림은 2-way set associative cache에 대한 그림입니다. 2-way이기 때문에 각각의 set에는 2개의 캐시 라인이 존재하게 되어 set의 갯수는 32개가 됩니다.
            
            각  캐시 블록은 태그, 인덱스, 오프셋으로 구성됩니다.
            
            태그는 메모리 주소의 상위 비트를 저장하여 해당 블록이 어떤 메모리 주소 범위에 속하는지를 확인합니다. 즉, 캐시에 저장된 블록이 메인 메모리의 어디 주소에 존재하는지를 확인하기 위한 비트입니다. 위 그림에서는 메인 메모리에 블록이 4096개가 존재하므로 총 13비트가 필요하게 됩니다. 이 때, 캐시의 인덱스와 오프셋을 뺀 비트 범위가 태그가 됩니다.
            
            인덱스는 메모리 주소의 중간 비트를 저장하여 해당 블록이 속한 set을 식별합니다. 위 그림에서는 32개의 set을 사용하기 때문에 5 bit를 사용하게 됩니다.
            
            마지막으로 offset은 메모리 주소의 하위 비트를 저장하여 블록 내에서 데이터의 위치를 결정합니다. 위 그림에서는 두 개의 블록을 구분하기 위해 1bit를 사용합니다.
            
            마지막으로 태그의 비트 범위는 총 13비트에서 인덱스 5bit와 오프셋 1bit를 뺀 7비트가 됩니다.
            
        - **완전 연관(fully associative) 캐시**
            
            완전 연관 캐시는 메모리 주소를 캐시 내의 어떤 위치에도 저장할 수 있는 캐시 구조입니다. 따라서, 어떤 주소든지 캐시 내의 어떤 위치에도 저장될 수 있기 때문에 캐시 미스가 발생할 확률이 적어지고, 캐시 히트율이 높아집니다.
            
            완전 연관 캐시에서는 메모리 주소를 캐시 태그와 비교하여 캐시 내에 해당 데이터가 저장되어 있는지 검사합니다. 캐시 태그는 메모리 주소의 일부분으로 구성되며, 태그가 일치하는 데이터가 캐시에 저장되어 있으면 캐시 히트가 발생하고, 그렇지 않으면 캐시 미스가 발생합니다.
            
            ![Fully associative cache](https://github.com/BangDori/CS_interview_Study/blob/main/os%26computer_structure/img/fully_associative_cache.png)
            
            완전 연관 캐시는 메모리의 모든 블록을 검색될 때까지 모든 캐시 라인을 비교합니다. 이는 하드웨어에서 처리되므로 매우 빠르게 수행됩니다.
            
            완전 연관 캐시의 단점은 태그 비교가 모든 캐시 엔트리에서 동시에 이루어지기 때문에 검색 속도가 느리다는 것입니다. 또한, 모든 메모리 주소를 캐시에 저장할 수 있기 때문에 캐시의 크기가 커지면 비용이 증가합니다. 따라서, 일반적으로는 집합 연관 캐시와 같은 다른 캐시 구조와 함께 사용하여 캐시의 성능을 최적화합니다.
            
            **n-way 집합 연관 캐시와의 차이점**
            
            완전 연관 캐시는 메모리의 모든 블록이 캐시의 모든 라인에 대해 경쟁을 하게 되는 방식으로 동작합니다. 반면에 n-way 집합 연관 캐시는 캐시 라인을 여러 개의 집합으로 나누어, 각 집합 내에서만 블록들이 경쟁하도록 동작합니다.
            
            예를 들어, 8-way 집합 연관 캐시의 경우, 캐시 내의 모든 블록은 8개의 집합 중 하나에 저장됩니다.
            
            n-way 집합 연관 캐시는 완전 연관 캐시보다 메모리의 모든 블록에 대해 캐시 라인을 비교하지 않으므로 검색 속도가 더 빠르고 캐시 라인의 개수를 줄이면서도 캐시 성능을 유지할 수 있기 때문에, 전체 캐시 크기를 줄일 수 있는 장점도 있습니다. 하지만 n-way 집합 연관 캐시는 탐색의 복잡도가 높아지기 때문에 구현이 조금 더 복잡합니다.
            
- **답안**
    
    캐시 미스는 컴퓨터에서 발생하는 현상으로, CPU가 데이터나 명령어를 찾을 때 캐시 메모리에 해당 데이터나 명령어가 없어서 메인 메모리에서 해당 데이터나 명령어를 가져오는 것을 말합니다. 캐시 미스의 주요 원인으로는 Compulsory miss, Capacity miss, Conflict miss가 있는데, 멀티 코어를 사용할 경우 Coherence miss도 발생할 수 있습니다.
    
    캐시 미스가 발생하면 성능이 저하될 수 있기 때문에, 적절한 캐시 크기와 캐시 알고리즘을 선택하여 캐시 히트율을 높이는 것이 중요합니다.
    
    - **[꼬리 질문]**
        
        **캐시 미스를 최소화 하기 위한 방법에는 어떠한 방법이 있나요?**
        
        - **답안**
            
            캐시 미스를 최소화하기 위한 방법으로는 예측 실행이 있습니다. 예측 실행은 캐시 미스가 발생하기 전에 미리 필요한 데이터를 캐시에 불러와 저장해 놓는 기술입니다.
            
            예를 들어, 프로그램에서 반복문을 사용하여 배열의 요소에 접근하는 경우가 있습니다. 이때, 캐시에서 해당 요소를 찾을 수 없는 경우 매번 메인 메모리에서 불러와야 하므로 성능이 저하됩니다. 이러한 경우, 미리 다음 요소를 예측하여 캐시를 불러와 놓는 방법을 사용할 수 있습니다. 
            
            다음 요소를 미리 예측하는 방법에는 요소 간 거리(Stride)가 일정하다는 가정을 기반으로 다음 요소의 위치를 예측하는 Stride-based Prediction, 이전 요소들의 패턴을 분석하여 다음 요소를 예측하는 방법인 패턴 기반 예측 방법 등이 있습니다.
            
- **캐시 사상 방식에는 어떤 것이 있는지 설명해주세요.**
    
    캐시 사상 방식에는 세 가지 종류가 있습니다. 각 블록을 캐시 내에서 유일한 위치에 1:1 매핑하는 직접 사상 캐시와 캐시를 여러 개의 집합으로 나눈 후, 각 집합마다 블록을 저장하는 집합 연관 사상 방식, 마지막으로 모든 블록이 어떤 위치든 매핑될 수 있는 완전 연관 사상 방식이 있습니다.
    
    직접 사상 방식의 경우 메모리 주소의 일부를 캐시의 인덱스로 사용하고, 나머지 부분을 오프셋으로 하는데, 이 방식은 구현이 간단하고 빠르지만, 캐시 충돌이 발생할 가능성이 높습니다.
    
    집합 연관 사상 방식과, 완전 연관 사상 방식의 경우 직접 사상 방식에서 발생하는 데이터 지역성의 문제를 보완하기 위한 방식인데, 집합 연관 사상 방식의 경우 집합에 여러 개의 블록을 저장할 수 있기 때문에 충돌이 발생할 가능성이 줄어듭니다.
    
    마지막으로 완전 연관 사상의 경우 각 블록이 전체 캐시 중 어느 위치에든 저장될 수 있기 때문에, 충돌은 발생하지 않지만, 모든 캐시 라인을 검색하기 때문에 검색 속도가 집합 연관 사상 방식에 비해 느릴 수 있습니다.
    
- **참고 자료**
    1. ChatGPT
    2. [https://lolki.tistory.com/2](https://lolki.tistory.com/2)
    3. [https://m.blog.naver.com/you_maybe/221730246096](https://m.blog.naver.com/you_maybe/221730246096)
    4. [https://en.wikipedia.org/wiki/Cache_placement_policies](https://en.wikipedia.org/wiki/Cache_placement_policies)
