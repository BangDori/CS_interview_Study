## FIFO와 SJF 두가지 스케쥴링 기법이 컴퓨터에 적합하지 않은 이유와 대안책을 설명해주세요.

- 자료 조사

### 사족

### 1. 스케쥴링이란?

- 일반적으로 처리할 일들의 진행순서를 정하는 일을 일컫는 말
  - **프로세스 스케쥴링**
    - CPU를 사용하려고 하는 프로세스들 사이의 우선 순위를 관리하는 일
  - **디스크 스케쥴링**
    - 디스크를 사용하려고 하는 프로세서들 사이의 우선 순위를 관리하는 일

<aside>
💡 스케줄링은 처리율과 CPU 이용률을 증가시키고, 오버헤드/응답시간/반환시간/대기시간을 최소화 시키기 위한 기법입니다. 즉, CPU가 쉬지않고 계속 열심히 일할 수 있도록 효율적인 계획을 잡아 주는 것이 스케줄링

</aside>

---

### 2. 스케쥴링 방식

- 스케쥴링은 적용 시점에 따라 비선점형 & 선점형의 2가지로 구분 가능

1. **비선점형 스케쥴링**
   1. 프로세스가 (실행->대기), (실행->종료) 로의 상태전이가 있을 때 적용
   2. 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법
   3. 선점 방식보다 스케줄러 호출 빈도가 낮고 문맥 교환에 의한 오버헤드도 적음
   4. 일괄처리 시스템에 적합하고, CPU 사용 시간이 긴 하나의 프로세스가 CPU 사용 시간이 짧은 여러 프로세스를 오랫동안 대기시킬 수 있으므로, 처리율이 떨어질 수 있다는 단점이 있다.
2. **선점형 스케쥴링**
   1. (실행->대기), (실행->준비), (대기->준비), (수행->종료) 모든 상태변화에서 적용
   2. 하나의 프로세스가 CPU를 할당 받아 실행하고 있을 때 우선 순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 기법
   3. 모든 프로세스에게 CPU 사용 시간을 동일하게 부여할 수 있으며, 빠른 응답시간을 요하는 대화식 시분할 시스템에 적합하며 긴급한 프로세서를 제어할 수 있다.

## 비선점형 스케줄링

### 1. FIFO

- 가장 간단한 방식으로 선입선출의 방식
- 먼저 들어오면 먼저 나가는 방식으로, 아무리 중요한 작업이 있다 하더라고 그 작업 보다 먼저 들어온 작업이 끝나기 전까지는 절대 먼저 실행될 수 없는 비효율적인 방식
- 기본 스케줄링 알고리즘으로 거의 사용되지 않음

![Feature_Of_FIFO](https://github.com/JungMunGyu/CS_interview_Study/blob/main/os&computer_structure/img/Feature_Of_FIFO.png?raw=true)

---

### 2. SJF

- 평균 대기 시간을 최소화하기 위해 CPU 점유 시간이 가장 짧은 프로세스에 CPU를 먼저 할당하는 방식
- cpu가 프로세스에 주어지면 cpu burst가 완료될 때까지 선점될 수 없다.

![Feature_Of_SJF](https://github.com/JungMunGyu/CS_interview_Study/blob/main/os&computer_structure/img/Feature_Of_SJF.png?raw=true)

## 선점형 스케줄링

### 1. SRT(Shortest Remaining Time)

- 비선점 스케줄링인 SJF 기법을 선점 형태로 변경한 기법
- SJF처럼 CPU 점유 시간이 가장 짧은 프로세스에 CPU를 먼저 할당하는 방식으로, 단지 차이점은 ‘선점형’으로 바뀌어 중요한 프로세스가 있으면 점유시간이 길어도 먼저 실행 시킬수 있는 권한이 생겼다는 것

---

### 2. RR (Round-Robin)

- 대화형 시스템에서 사용되는 선점 스케줄링 방식이다.
- 프로세스가 도착한 순서대로 프로세스를 디스패치하지만 정해진 시간 할당량(또는 시간 간격)에 의해 실행을 제한한다.
- 즉, 시간 할당량을 매 프로세스에 주고 할당된 시간 안에 완료되지 못한 프로세스는 준비 큐의 맨 뒤에 배치되도록 하여 CPU를 독점하지 않고 공평하게 이용될 수 있게 한다.

<aside>
💡 즉, process에게 일정 시간동안 cpu제어권을 주고 시간이 종료되면 다음 process에게 제어권을 넘기는 알고리즘이다.

</aside>

- Process가 제한 시간이 끝나기 전에 수행이 종료되면 ready queue에서 다음 process를 찾아서 수행시킵니다.
  - process가 제한시간안에 완료하지 못했을 경우 interrupt가 발생하여 다음 process로 넘어가기 위해 context switching이 발생
- 성능
  - 평균 CPU 소요시간에 대한 시간 간격의 길이에 따라 달라진다.
    - 간격이 너무 큰 경우 = FIFO 정도로 성능이 낮아짐
    - 간격이 너무 짧은 경우 = 잦은 문맥 교환이 작업 수행을 방해하여 오버헤드가 크게 증가
  - 가장 적절한 시간 간격은 시스템 형태에 달려 있다.
    - 대화형 환경에서 사용자가 간단한 요청을 한 경우라면 시스템은 빠른 응답시간을 요구한다.
    - 일괄처리 시스템이라면 응답시간은 중요한 것이 아니고 오버헤드가 중요한 요인이 된다.
  - 적절한 시간 간격을 결정하는 데는 일반적인 규칙 두 가지가 있다.
    - 80%의 CPU 사이클을 처리할 수 있도록 하는 것
    - 한 번의 문맥 교환에 걸리는 시간보다 100배 정도는 길어야 한다.

![Feature_Of_RR](https://github.com/JungMunGyu/CS_interview_Study/blob/main/os&computer_structure/img/Feature_Of_RR.png?raw=true)

### 3. RR 스케줄링의 예시 1

- 프로세스는 4개 시간 할당량은 3

![Ex_Of_RR1](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/43e37206-a4de-4e42-9d68-09e04736a879/Ex_Of_RR1.png?raw=true)

- 처음에는 프로세스 A만 도착했으므로 바로 디스패치하여 실행시킨다.
  - 시간 할당량 3이 지날 동안 프로세스 A는 계속 실행 중이고 준비 큐에는 프로세스 B,C,D가 순서대로 도착하여 기다리고 있다.
  - 따라서 RR 스케줄링 알고리즘은 프로세스 A를 준비 큐의 맨 뒤로 배치시키고 다음 차례인 프로세스 B를 디스패치하여 실행시킨다.
- 시간 할당량 3이 지나는 동안 프로세스 B도 마침 종료를 하게되어 다음 순서인 프로세스 C를 디스패치하여 실행시킨다.
  - 프로세스 C는 1만큼의 시간 만에 종료되어 바로 다음 순서인 프로세스 D를 디스패치하여 실행시킨다.
- 다시 시간 할당량 3이 지나도 프로세스 D는 종료하지 못하여 RR 스케줄링은 프로세스 D를 준비 큐의 맨 뒤로 배치시키고, 다음 차례인 프로세스 A를 디스패치하여 실행시킨다.
- 시간 할당량 3이 지나면 A도 종료가 되고, 마지막으로 프로세스 D를 디스패치하여 실행시키면 1만큼 지난 뒤 종료

![Ex_Of_RR1_Answer](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/43e37206-a4de-4e42-9d68-09e04736a879/Ex_Of_RR1_Answer.png?raw=true)

---

### 4. RR 스케줄링의 예시 2 - 도착시간이 다를 때

![Ex_Of_RR2](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/43e37206-a4de-4e42-9d68-09e04736a879/Ex_Of_RR2.png?raw=true)

![Ex_Of_RR2_Answer](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/43e37206-a4de-4e42-9d68-09e04736a879/Ex_Of_RR2_Answer.png?raw=true)

- 답안

  - FIFO와 SJF는 대표적인 비선점형 스케줄링기법중 하나이다. FIFO는 장기 실행 프로세스가 있으면 뒤에 있는 모든 프로세스를 대기시켜 평균 대기 시간이 길어지며 최악의 대기시간이 될 수 있다는 단점이 있으며, SJF는 짧은 작업이 항상 실행되므로 긴 작업이 계속 대기하는 기아현상이 생길 수 있고, 기본적으로 불공정한 작업을 실행한다. 또한 작업 시간을 예측해야하는 데, 실제 작업 시간을 정확히 예측하기 어렵다는 점도 컴퓨터에 사용하기 어려운 이유중에 하나이다. 따라서, 우리의 컴퓨터는 우선순위 스케줄링과 RR스케줄링을 합친 형태로 사용하는데 우선순위 스케줄링은 프로세스에 우선순위를 할당에 가장 높은 우선순위를 가진 프로세스를 CPU에 할당하는 알고리즘이고, RR은 프로세스에게 일정 시간동안 CPU의 제어권을 주고 시간이 종료되면 다음 프로세스에게 제어권을 넘기는 알고리즘이다. 우선순위 알고리즘의 단점인 기아현상은 에이징을 통해 해결하고, RR을 통해 CPU를 독점하지 않고 공평하게 이용할 수 있게 된다. 하지만 시간 시간 할당량이 너무 길어진다면 FIFO스케줄링과 큰 차이가 없을 수 있으니 사용에 주의해야 한다

- 질문

  ### 우선순위 스케줄링과 SJF의 대표적인 단점인 기아를 해결하기 위한 방법?

  - 답
    - 에이징 기법을 사용 : 시간이 지날수록 우선순위를 높여줌

- Reference
  [Round-Robin(RR)이란? , CPU-Scheduling들](https://jwprogramming.tistory.com/17)

  [[운영체제]RR(Round Robin라운드로빈)순환할당스케줄링, time quantum 타임퀀텀](https://jhnyang.tistory.com/entry/운영체제RRRound-Robin라운드로빈순환할당스케줄링-time-quantum-타임퀀텀)

  [[운영체제] RR(Round Robin) 스케줄링](https://yoons2owo.tistory.com/27)
