# 인덱스(Index)에 대한 설명과 , 장/단점에 대해 아는대로 말해주세요

- **자료 조사**
    
    ### 인덱스(Index)란?
    
     인덱스(Index)는 데이터베이스의 테이블에 대한 검색 속도를 향상 시켜주는 자료구조입니다. 테이블의 특정 컬럼(Column)에 인덱스를 생성하면, 해당 컬럼의 데이터를 정렬한 후 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장이 됩니다. 컬럼의 값과 물리적 주소를 (key, value)의 한 쌍으로 저장하게 됩니다.
    
    인덱스는 책에서의 목차 혹은 색인이라고 생각하면 되는데, 책에서 원하는 내용을 찾을 때 만약 목차나 색인을 알고 있다면 훨씬 빠르게 찾을 수 있는데, 마찬가지로 테이블에서 원하는 데이터를 찾기 위해 인덱스를 이용하면 빠르게 찾을 수 있다.
    
    ![[그림 1] 인덱스와 테이블](https://github.com/BangDori/CS_interview_Study/blob/main/database/img/index%2Btable.png)
    
    - **인덱스(Index)의 장단점**
        
        **장점**
        
        1. 테이블을 검색하는 속도와 성능이 향상된다.
        2. 인덱스에 의해 데이터들이 정렬된 형태를 갖는다.
            - 기존에는 Where문을 통해 특정 조건의 데이터를 찾기 위해 테이블의 전체를 비교해야 하는 ‘풀 테이블 스캔(Full Table Scan)’ 작업이 필요했는데, 인덱스를 이용하면 데이터들이 정렬되어 있기 때문에 조건에 맞는 데이터를 빠르게 찾을 수 있다.
        
        **단점**
        
        1. 인덱스를 관리하기 위한 추가적인 작업이 필요하다.
            - 인덱스를 항상 정렬된 상태로 유지해야 하기 때문에 인덱스가 적용된 컬럼에 삽입(INSERT), 삭제(DELETE), 수정(UPDATE) 작업을 수행하면 다음과 같은 추가 작업이 필요하다.
                - INSERT: 새로운 데이터에 대한 인덱스를 추가
                - DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 수행
                - UPDATE: 기존의 인덱스를 사용하지 않음 처리 및 갱신된 데이터에 대한 인덱스 추가
            
            - 이처럼 인덱스의 수정 또한 추가적인 작업이 필요하기 때문에 데이터의 수정이 잦은 경우에는 성능이 낮아지게 된다.
        2. 추가적인 저장 공간이 필요하다.
            - 데이터의 인덱스를 제거하는 것이 아니라 ‘사용하지 않음’으로 처리하게 되면, 실제 데이터에 비해 인덱스가 과도하게 커지게 되며, 사용하지 않는 데이터가 제거되는 것이 아니기에, 추가적인 저장 공간이 많이 필요해지게 된다.
        
    - **인덱스를 사용하면 좋은 경우**
        
        인덱스를 효율적으로 사용하기 위해서는 데이터의 range가 넓고 중복이 적을수록, 조회가 많거나 정렬된 상태가 유용한 컬럼에 사용하는 것이 좋다. 따라서 다음과 같은 경우에 인덱스를 사용하면 효율적이다.
        
        - 규모가 큰 테이블
        - 삽입, 수정, 삭제 작업이 자주 발생하지 않는 컬럼
        - WHERE나 ORDER BY, JOIN 등이 자주 사용되는 컬럼
        - 데이터의 중복도가 낮은 컬럼
    - **인덱스를 구현한 자료구조**
        
        인덱스는 여러 자료구조를 이용해서 구현할 수 있는데, 대표적으로 해시 테이블(Hash Table)과 B+Tree가 있다.
        
        ### 해시 테이블(Hash Table)
        
        해시 테이블은 key와 value를 한 쌍으로 데이터를 저장하는 자료구조이다. (key, value)로 쌍을 표현하며, key값을 이용해 대응되는 value값을 구하는 방식이다. 해시 충돌이라는 변수가 존재하지만, 해시 함수가 잘 짜여져 있는 경우라면 평균적으로 O(1)의 매우 빠른 시간만에 원하는 데이터를 탐색할 수 있는 구조이다.
        
        해시 테이블을 이용한다면 인덱스는 (key, value) = (컬럼의 값, 데이터의 위치)로 구현하는데, 해시 테이블은 실제로 인덱스에서 잘 사용되지 않는다.
        
        그 이유는, 해시 테이블은 등호(=) 연산에 최적화되어있기 때문에 등호 연산을 사용하여 데이터를 검색하는 경우에는 좋은 성능을 보인다.
        
        하지만 데이터베이스에서는 등호 연산 보다는 부등호(<, >) 연산이 자주 사용되는데, 해시 테이블 내의 데이터들은 정렬되어 있지 않으므로 특정 기준보다 크거나 작은 값을 빠른 시간 내에 찾을 수가 없다.
        
        ### B+Tree
        
        ![[그림 2] B-Tree](https://github.com/BangDori/CS_interview_Study/blob/main/database/img/B-tree.png)
        
        기존의 B-Tree는 어느 한 데이터의 검색은 효율적이지만, 모든 데이터를 한 번 순회하는 데에는 트리의 모든 노드를 방문해야 하므로 비효율적이다. 이러한 B-Tree의 단점을 개선시킨 자료구조가 B+Tree이다.
        
        B+Tree는 오직 leaf node에만 데이터를 저장하고 leaf node가 아닌 node에서는 자식 포인터의 위치만을 저장한다. 그리고 leaf node끼리는 Linked list 형식으로 연결되어 있어 있어 검색에 용이하다.
        
        ![[그림 3] B+Tree](https://github.com/BangDori/CS_interview_Study/blob/main/database/img/B%2Btree.png)
        
        B+Tree에서는 반드시 leaf node에만 데이터가 저장되기 때문에 중간 node에서 key를 올바르게 찾기 위해 Key가 중복될 수 있다.
        
        B+Tree에는 어떠한 장점이 존재할까?
        
        1. leaf node를 제외하고는 포인터만을 저장하기 때문에 메모리를 확보할 수 있으며 하나의 node에 더 많은 포인터를 가질 수 있기 때문에 트리의 높이가 더 낮아지므로 검색 속도를 높일 수 있다.
        2. Full scan을 하는 경우 B-Tree는 모든 node를 확인해야 하는 반면, B+Tree는 leaf node에만 데이터가 저장되어 있고, leaf node끼리 연결리스트 형식으로 연결되어 있기 때문에 선형 시간이 소모된다.
- **답안**
    
    인덱스는 데이터베이스에서 데이터 검색 속도를 높이기 위해 사용되는 데이터 구조입니다. 인덱스는 특정 컬럼의 값을 정렬하고, 이를 이용해 빠른 검색이 가능하게 합니다.
    
    인덱스의 장점으로는 검색 속도 향상과 데이터 무결성 보장 등이 있으며 단점으로는 디스크 공간과 인덱스 수가 많아질수록 데이터베이스의 관리가 어려워진다는 점이 있습니다.
    
    따라서, 인덱스는 검색이 자주 일어나는 컬럼이나, 중복된 데이터가 적은 컬럼에서 사용하는 것이 좋습니다. 또한 대용량의 데이터를 다루는 경우에도, 검색 속도를 높이기 위해 적절한 인덱스를 사용하면 성능을 향상시킬 수 있습니다.
    
- **추가 질문**
    
    **1-1. 검색이 많은 경우에는 인덱스를 사용하는 것이 좋고, 수정이 자주 일어나는 경우에는 인덱스를 사용하지 않는 것이 좋다고 했는데, 검색과 수정이 둘 다 자주 일어나는 경우에는 인덱스를 어떠한 방식으로 사용할 것인지?**
    
    저는 검색과 수정이 자주 발생하는 테이블에 대해 검색과 수정이 동일한 테이블에 이루어지지 않도록 테이블을 분리할 수 있을지에 대해 우선적으로 고려해볼 것입니다.
    
    만약, 테이블을 분리할 수 없다면, 데이터베이스의 크기를 고려하여 메모리의 효율적인 관리를 위해 인덱스를 사용하지 않을 것입니다. 하지만 데이터베이스의 크기가 충분하다면, 검색과 수정의 빈도에 따라 인덱스를 사용하는 것을 고려해볼 것 같습니다.
    
- **참고 자료**
    - [https://rebro.kr/167](https://rebro.kr/167)
    - [https://choicode.tistory.com/27](https://choicode.tistory.com/27)
